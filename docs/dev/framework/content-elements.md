---
title: "Content Elements"
description: "Contao's fundamental content blocks."
aliases:
    - /documentation/content-elements/
    - /framework/content-elements/
---

{{% notice info %}}
This covers the documentation on how to create content elements in Contao **4.6**
and up. In previous Contao version, Content elements must extend from `\Contao\ContentElement`
and then be registered via the `$GLOBAL['TL_CTE']` array.
{{% /notice %}}

In Contao, Content Elements are the fundamental content blocks. In its simplest
form it is a fragment controller which receives data in form of a content model
and returns a response.

These elements are implemented as so called _fragment controllers_ which  Contao
then renders into the main content, using their defined renderer. See the [caching documentation][fragments]
for more information.

Creating a content element is very similar to creating [front end modules][modules].


## Definition

To create a new content element, the following things must be defined and implemented:

* __Fragment Controller__ <br>
  The actual implementation of the content element is done via a class that extends
  from `AbstractContentElementController` of the Contao core.

* __Service Tag__ <br>
  To identify the controller as a Contao content element, the service must be tagged
  with service tag `contao.content_element`.

  * __Type__ <a id="type"></a><br>
    The *type* of a content element is a specific string which is used to identify
    the element's template and DCA palette. The `type` can be set in the service
    tag. If omitted the type will be automatically generated by converting the
    class name of the controller from pascal case to snake case and removing a possible
    `Controller` postfix.
  
  * __Category__ <br>
    All content elements are categorised within the type dropdown of the content element's
    palette. A `category` must be defined in the service tag for each content element.

* __Template__ <br>
  If not specified, the template name follows the naming convention mentioned for the _type_ and prpends it it with the
  prefix `ce_` in case of  legacy [PHP templates][LegacyTemplates]. For [Twig templates][TwigTemplates] it will default
  to `content_element/<type>.html.twig`.


## Example

Consider this very simple example of a content element:

```php
// src/Controller/ContentElement/ExampleElementController.php
namespace App\Controller\ContentElement;

use Contao\ContentModel;
use Contao\CoreBundle\Controller\ContentElement\AbstractContentElementController;
use Contao\CoreBundle\DependencyInjection\Attribute\AsContentElement;
use Contao\Template;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

#[AsContentElement(category: 'texts')]
class ExampleElementController extends AbstractContentElementController
{
    protected function getResponse(Template $template, ContentModel $model, Request $request): Response
    {
        $template->text = $model->text;
        
        return $template->getResponse();
    }
}
```

In this example the service tag was implemented via PHP attributes (see the different [registration types](#registration) 
below).

In order to be able to set the options for this content element and fill it with content in the back end, we also need
to define a specific [palette][palettes] in the `tl_content` DCA configuration. The palette key is based on the _type_
of the content element. Since we did not specify a type in our example it defaults to `example_element` as explained
above.

```php
// contao/dca/tl_content.php
$GLOBALS['TL_DCA']['tl_content']['palettes']['example_element'] = 
    '{type_legend},type;{text_legend},text'
;
```

This very simple palette enables a back end user to fill the (pre-existing) field `text` via the create and edit view of
this content element.

Using the naming convention for templates mentioned above, the final template name for this content element will be
`ce_example_element` for [PHP templates][LegacyTemplates]:

```html
<!-- contao/templates/ce_example_element.html5 -->
<div class="example-element">    
  <?= $this->text; ?>
</div>
```

{{< version-tag "4.13" >}} And `content_element/example_element` for [Twig templates][TwigTemplates]:

```twig
{# templates/content_element/example_element.html.twig #}
<div class="example-element">    
    {{ text|raw }}
</div>
```

A template instance of this template will automatically be generated and passed to the controller's main method. The
controller returns the parsed template as a response.


## Registration

As mentioned previously a content element is registered by registering a controller as a service and tagging it with the 
`contao.content_element` service tag. The service tag supports the following options:

| Option   | Type      | Description                                                                                                                               |
| -------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------|
| name     | `string`  | Must be `contao.content_element`.                                                                                                         |
| type     | `string`  | _Optional:_ The *type* mentioned in [Type]({{% ref "#type" %}}) can be customized.                                                        |
| category | `string`  | Defines in which option group this content element will be placed in the content element selector.                                        |
| template | `string`  | _Optional:_ Override the generated template name.                                                                                         |
| renderer | `string`  | _Optional:_ The renderer can be changed to `inline` or `esi`. Defaults to `forward`. See [Caching Fragments][fragments] for more details. |
| method   | `string`  | _Optional:_  Which method should be invoked on the controller.                                                                            |
| nestedFragments | `bool`/`array` | _Optional:_ Allows [nested fragments](#nested-fragments) for this content element. |

Applying the service tag can either be done via PHP attributes, annotations or via the YAML configuration.

{{< tabs groupid="attribute-annotation-yaml" style="code" >}}

{{% tab title="Attribute" %}}
{{< version-tag "4.13" >}} A content element can be registered using the `AsContentElement` PHP attribute.

```php
// src/Controller/ContentElement/ExampleElementController.php
namespace App\Controller\ContentElement;

use Contao\CoreBundle\Controller\ContentElement\AbstractContentElementController;
use Contao\CoreBundle\DependencyInjection\Attribute\AsContentElement;
use Contao\ContentModel;
use Contao\Template;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

#[AsContentElement(category: 'texts')]
class ExampleElementController extends AbstractContentElementController
{
    protected function getResponse(Template $template, ContentModel $model, Request $request): Response
    {
        return $template->getResponse();
    }
}
```

The above example only defines the `category` attribute (which is actually optional for the PHP attribute - the default 
category is `miscellaneous`). If you wish you can also define the other options of the service tag:

```php
// src/Controller/ContentElement/ExampleElementController.php
namespace App\Controller\ContentElement;

use Contao\CoreBundle\Controller\ContentElement\AbstractContentElementController;
use Contao\CoreBundle\DependencyInjection\Attribute\AsContentElement;
use Contao\ContentModel;
use Contao\Template;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

#[AsContentElement('example_element', 'texts', 'ce_example', '__invoke', 'forward')]
class ExampleElementController extends AbstractContentElementController
{
    protected function getResponse(Template $template, ContentModel $model, Request $request): Response
    {
        return $template->getResponse();
    }
}
```

However, it is recommended to only define what you need and otherwise leave the defaults.
{{% /tab %}}

{{% tab title="Annotation" %}}
{{< version-tag "4.8" >}} A content element can be registered using the `ContentElement` annotation. The annotation can be used on the class of the content element,
if the class is invokable (has an `__invoke` method) or extends from the `AbstractContentElementController`. Otherwise the annotation can be 
used on the method that will deliver the response.

```php
// src/Controller/ContentElement/ExampleElementController.php
namespace App\Controller\ContentElement;

use Contao\CoreBundle\Controller\ContentElement\AbstractContentElementController;
use Contao\CoreBundle\ServiceAnnotation\ContentElement;
use Contao\ContentModel;
use Contao\Template;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

/**
 * @ContentElement(category="texts")
 */
class ExampleElementController extends AbstractContentElementController
{
    protected function getResponse(Template $template, ContentModel $model, Request $request): Response
    {
        return $template->getResponse();
    }
}
```

The above example only defines the mandatory `category` attribute. If you wish you can also define the other options of 
the service tag:

```php
// src/Controller/ContentElement/ExampleElementController.php
namespace App\Controller\ContentElement;

use Contao\CoreBundle\Controller\ContentElement\AbstractContentElementController;
use Contao\CoreBundle\ServiceAnnotation\ContentElement;
use Contao\ContentModel;
use Contao\Template;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

/**
 * @ContentElement("example_element", "texts", "ce_example", "__invoke", "forward")
 */
class ExampleElementController extends AbstractContentElementController
{
    protected function getResponse(Template $template, ContentModel $model, Request $request): Response
    {
        return $template->getResponse();
    }
}
```

However, it is recommended to only define what you need and otherwise leave the defaults.
{{% /tab %}}

{{% tab title="YAML" %}}
{{< version-tag "4.8" >}} A content element can be registered using the `contao.content_element` service tag.

```yaml
# config/services.yaml
services:
    App\Controller\ContentElement\ExampleElementController:
        tags:
            -
                name: contao.content_element
                category: texts
```
```php
// src/Controller/ContentElement/ExampleElementController.php
namespace App\Controller\ContentElement;

use Contao\CoreBundle\Controller\ContentElement\AbstractContentElementController;
use Contao\ContentModel;
use Contao\Template;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class ExampleElementController extends AbstractContentElementController
{
    protected function getResponse(Template $template, ContentModel $model, Request $request): Response
    {
        return $template->getResponse();
    }
}
```

The above example only defines the mandatory `category` attribute. If you wish you can also define the other options of 
the service tag:

```yaml
# config/services.yaml
services:
    App\Controller\ContentElement\ExampleElementController:
        tags:
            -
                name: contao.content_element
                category: texts
                template: ce_example
                renderer: forward
                method: __invoke
```

However, it is recommended to only define what you need and otherwise leave the defaults.
{{% /tab %}}

{{< /tabs >}}

You can also use class constants within attributes and annotations. This can be helpful to make the module's type a
reusable reference:

```php
#[AsContentElement(ExampleElementController::TYPE)]
class ExampleElementController extends AbstractContentElementController
{
    public const TYPE = 'my_element';
}
```

```php
// contao/dca/tl_content.php
use App\Controller\ContentElement\ExampleElementController;

$GLOBALS['TL_DCA']['tl_content']['palettes'][ExampleElementController::TYPE] = 
   '{type_legend},type;{text_legend},text'
;
```

```php
// contao/languages/en/default.php
use App\Controller\ContentElement\ExampleElementController;

$GLOBALS['TL_LANG']['CTE'][ExampleElementController::TYPE] = [
    'My Example Element', 
    'A Content Element for testing purposes.',
];
```


## Translations

In order to have a nice label in the back end, we also need to add a translation
for our content element - otherwise it will only be named *example_element*.
The translation needs to be set as follows:

```php
// contao/languages/en/default.php
$GLOBALS['TL_LANG']['CTE']['example_element'] = [
    'My Content Element', 
    'A Content Element for testing purposes.',
];
```

If you used a custom category for your content element, its label can also be translated there.


## Page Model

{{< version "4.9.10" >}}

If your fragment extends from `AbstractContentElementController` (or just `AbstractFragmentController`)
you can use `$this->getPageModel()` in order to receive the `\Contao\PageModel`
object of the currently rendered page of Contao's site structure.

```php
// src/Controller/ContentElement/ExampleElementController.php
namespace App\Controller\ContentElement;

use Contao\ContentModel;
use Contao\CoreBundle\Controller\ContentElement\AbstractContentElementController;
use Contao\CoreBundle\DependencyInjection\Attribute\AsContentElement;
use Contao\Template;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

#[AsContentElement(category: 'texts')]
class ExampleElementController extends AbstractContentElementController
{
    protected function getResponse(Template $template, ContentModel $model, Request $request): Response
    {
        $page = $this->getPageModel();

        // Get some information about the current page
        $template->rootTitle = $page->rootPageTitle ?: $page->rootTitle;
        
        return $template->getResponse();
    }
}
```


## Wrapper Elements

In Contao there are special content elements called "wrappers" which you insert before and after one or a group of content elements. These
wrappers affect the back end view, indicating that all elements contained within the two wrappers are descendants of the parent wrapper. The
wrapper content elements typically consist of a `start`and `stop` element, though there are also wrappers of type `single` and `separator`. 
The `start` element typically opens a specific HTML tag, while the `stop` element will close it again.

In order to define that a content element is a wrapper of a specific type, it needs to be registered in the `$GLOBALS['TL_WRAPPERS']` array
in your `contao/config/config.php`. The `$GLOBALS['TL_WRAPPERS']` array holds the element types for each type of wrapper. For example:

```php
// contao/config.php
$GLOBALS['TL_WRAPPERS']['start'][] = 'my_start_element';
$GLOBALS['TL_WRAPPERS']['stop'][] = 'my_stop_element';
```


## Nested Fragments

{{< version "5.3" >}}

An alternative approach to the aforementioned wrapper elements are so called "nested fragments". These allow you to
nest other content elements within a parent content element for which nested fragments are enabled. The following
screenshot shows the _Element group_ content element of the Contao Core:

![Element group content element]({{% asset "images/dev/framework/nested-fragments.png" %}}?classes=shadow)

Just as with page articles, news archives, etc. this content element allows you to edit its children via 
![edit children icon]({{% asset "icons/children.svg" %}}?classes=icon) which then works the same way as within the
article of a page.

Allowing nested fragments for your content element works via the `nestedFragments` option in the service tag:

{{< tabs groupid="attribute-annotation-yaml" style="code" >}}

{{% tab title="Attribute" %}}
```php
#[AsContentElement(nestedFragments: true)]
class ExampleElementController extends AbstractContentElementController
{
    protected function getResponse(FragmentTemplate $template, ContentModel $model, Request $request): Response
    {
        return $template->getResponse();
    }
}
```
{{% /tab %}}

{{% tab title="Annotation" %}}
```php
/**
 * @ContentElement(category="miscellaneous", nestedFragments=true)
 */
class ExampleElementController extends AbstractContentElementController
{
    protected function getResponse(FragmentTemplate $template, ContentModel $model, Request $request): Response
    {
        return $template->getResponse();
    }
}
```
{{% /tab %}}

{{% tab title="YAML" %}}
```yaml
services:
    App\Controller\ContentElement\ExampleElementController:
        tags:
            -
                name: contao.content_element
                nestedFragments: true
```
{{% /tab %}}

{{< /tabs >}}

With nested fragments it is also possible to restrict the fragment's children to specific content element types. Say you
want to implement a specific slider content element which should only allow images and videos as its children. Then
instead of defining `true` for the tag's `nestedFragments` option you can instead pass an additional option called
`allowedTypes`:

{{< tabs groupid="attribute-annotation-yaml" style="code" >}}

{{% tab title="Attribute" %}}
```php
#[AsContentElement(nestedFragments: ['allowedTypes' => ['image', 'video']])]
class ExampleElementController extends AbstractContentElementController
{
    protected function getResponse(FragmentTemplate $template, ContentModel $model, Request $request): Response
    {
        return $template->getResponse();
    }
}
```
{{% /tab %}}

{{% tab title="Annotation" %}}
```php
/**
 * @ContentElement(category="miscellaneous", nestedFragments={"allowedTypes" = {"image", "video"}})
 */
class ExampleElementController extends AbstractContentElementController
{
    protected function getResponse(FragmentTemplate $template, ContentModel $model, Request $request): Response
    {
        return $template->getResponse();
    }
}
```
{{% /tab %}}

{{% tab title="YAML" %}}
```yaml
services:
    App\Controller\ContentElement\ExampleElementController:
        tags:
            -
                name: contao.content_element
                nestedFragments:
                    allowedTypes: ['image', 'video']
```
{{% /tab %}}

{{< /tabs >}}

Now all you have to do is render these fragments in your template. The `AbstractContentElementController` from which
your content element likely extends from automatically passes the available nested fragments to your template within
the `nested_fragments` template variable. This will be a collection of `ContentElementReference` objects which you can
render via the `content_element()` Twig function:

```twig
{# templates/content_element/example.html.twig #}
{% extends "@Contao/content_element/_base.html.twig" %}

{% block content %}
    {% for fragment in nested_fragments %}
        {{ content_element(fragment) }}
    {% endfor %}
{% endblock %}
```


## Read More

* [Manipulate and create palettes][palettes]
* [Create and use templates][templates]
* [Customize Caching][caching]


[palettes]: /reference/dca/palettes/
[templates]: /framework/templates/
[caching]: /framework/caching/
[modules]: /framework/front-end-modules/
[fragments]: /framework/caching/#caching-fragments
[LegacyTemplates]: /framework/templates/legacy/
[TwigTemplates]: /framework/templates/
